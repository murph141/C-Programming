#include "pa11.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//Constant declarations
#define PUZZLESIZE 16
#define NUMBEROFMOVES 4
#define SIDELENGTH 4

//Function declarations
int compare(const void *, const void *);
int string_locate(char *, int, char);
void char_swap(char *, char *);
void generateAllHelper(MoveTree *, int, const char *, char *, int);

/**
  IMPORTANT INFORMATION

  This assignment comes with the following files:
  + "README", please read all of this before asking questions.
  + "pa11.c", do not edit this file. (See note below.)
  + "pa11.h", do not edit this header file.
  + "answer11.c", the file you must SUBMIT at the assignment deadline.
  + "tester", a binary (encrypted) file that runs tests on a compiled 
  executable.

  You are responsible for testing your code as you write it. The tester
  binary will run some tests; however, it is specifically designed to be
  too slow to be executed in an edit-compile-test loop. You must set up
  this loop yourself. This is EXTREMELY important if you want to learn
  how to code faster and more accurately, which is why we do this.

  TO TEST YOU CODE

  You should set up your own "main(...)" function, in which you create
  data an manipulate it with specific functions. For example, you can
  run the "isValidState(...)" function as follows:

  int main(int argc, char * * argv)
  {
  isValidState("ABCDE");
  return 0;
  }
*/


/** 
 * Return TRUE iff 'state' is a valid puzzle state.
 *
 * To do this, you have to check:
 * strlen(state) == 16
 * That 'state' only contains characters from "123456789ABCDEF-"
 * That 'state' contains no repeated characters
 *
 * The easiest way to do this is to:
 * (1) Copy 'state' into a buffer that you create
 * (2) Sort the characters in your buffer. (Use qsort.)
 * (3) Check that buffer is equal to "-123456789ABCDEF"
 */
int isValidState(const char * state)
{
  if(strlen(state) == PUZZLESIZE) //Compare string length to puzzle size
  {
    char * copy = strdup(state); //Use strdup, taken from ECE 264 course notes

    qsort(copy, PUZZLESIZE, sizeof(char), compare); //Call qsort to sort the value

    if(strcmp(copy, "-123456789ABCDEF") == 0)
    {
      free(copy); //Free the dumped string
      return TRUE;
    }
    free(copy);
  }

  return FALSE;
}

//Compare the two values
int compare(const void * s1, const void * s2)
{
  int int1 = * (char *) s1; //Type cast the two pointers as character arrays
  int int2 = * (char *) s2;

  if(int1 < int2)
  {
    return -1;
  }

  if(int1 > int2)
  {
    return 1;
  }

  return 0;
}


/** 
 * Return TRUE iff all characters in 'moves' are in "RLUD"
 *
 * To do this you must iterate over the string, and check that
 * each character is one of { 'R', 'L', 'U', 'D' }
 */ 
int isValidMoveList(const char * moves)
{
  int i = 0; //Counter variable
  while(moves[i] != '\0') //Iterate through movelist until a null character is found
  {
    if(!(moves[i] == 'R' || moves[i] == 'L' || moves[i] == 'U' || moves[i] == 'D'))
    {
      return FALSE;
    }
    i++; //Incrememnt the counter
  }

  return TRUE;
}

/**
 * Prints the puzzle-state as a 2d matrix. 
 *
 * This function is for debugging purposes only. It is strongly 
 * recommended that you write it; however, it is will not be graded.
 */
void printPuzzle(const char * state)
{
  int row, col;
  for(row = 0; row < SIDELENGTH; ++row) {
    for(col = 0; col < SIDELENGTH; ++col) {
      printf(" %c", state[row*SIDELENGTH + col]);
    }
    printf("\n");
  }
}


/**
 * Apply move 'm' to puzzle-state 'state'. Return TRUE iff success.
 *
 * You can assume that 'm' is one of { 'U', 'D', 'L', 'R' }, and 
 * that 'state' is a valid state, which means it contains a '-' 
 * character.
 *
 * The simplest way to write this function is as follows:
 * (1) Find the row and column of the space character '-'
 *     (1.a) Search 'state' for the 'position' of the '-' character
 *     (1.b) The 'row' will be 'position / SIDELENGTH'
 *     (1.c) The 'col' will be 'position % SIDELENGTH'
 * (2) Look at the move 'm', and calculate the _new_ row and col
 *     (2.a) If 'm' == 'U', then 'new_row = row-1' and 'new_col = col'
 *     etc.
 * (3) Check that 'new_row' and 'new_col' are in bounds. They must
 *     be >= 0 and < SIDE_LENGTH. If they are _not_ in bounds, then
 *     return FALSE
 * (4) Calculate the 'target_position' for the '-' character. It will
 *     be 'new_row * SIDELENGTH + new_col'
 * (5) Swap the characters at 'position' and 'target_position'
 */
int move(char * state, char m)
{    
  int location = string_locate(state, PUZZLESIZE, '-') - 1; //Location in the 15-puzzle using 0 as the starting index
  int row = location / SIDELENGTH; //Calculate row
  int col = location % SIDELENGTH; //Calculate column

  int new_row = row; //New row is equal to the original row
  int new_col = col; //New col is equal to the original col

  switch(m) //Do different things depending on what character is passed
  {
    case 'U':
      new_row--;
      break;
    case 'D':
      new_row++;
      break;
    case 'L':
      new_col--;
      break;
    case 'R':
      new_col++;
      break;
    default:
      return FALSE; //If the character is not for Up, Down, Left, or Right, return false
  }

  if((new_row < 0 || new_col < 0) || (new_row > (SIDELENGTH - 1) || new_col > (SIDELENGTH - 1)))
  {
    return FALSE;
  }

  int new_pos = new_row * SIDELENGTH + new_col;

  char_swap(&state[location], &state[new_pos]); //Swap the two characters

  return TRUE;
}


//Swap function
void char_swap(char * c1, char * c2)
{
  char temp = * c1;
  * c1 = * c2;
  * c2 = temp;
}


int string_locate(char * string, int length, char needle)
{
  int i = 0;
  int location = 0;

  for(; i < length; i++)
  {
    if(string[i] == needle)
    {
      i = length; //When the location is found, exit the loop my making i too large
    }
    location++; //Incrememnt location
  }

  return location;
}

/**
 * Apply the moves in 'movelist' to state. 
 *
 * If the sequence is invalid, then print "I" on a single line.
 * Otherwise, print the new state after moves have been applied.
 *
 * To do this, you need:
 * (1) A for-loop to iterate over characters 'm' in 'movelist'
 *     (1.a) Call move(state, m)
 *     (1.b) If 1.a fails, then print "I" on a single line
 * (2) If you never failed in (1), then print the final state on a 
 *     single line.
 */
void processMoveList(char * state, const char * movelist)
{
  int i = 0;

  for(;movelist[i] != '\0'; i++)
  {
    int test = move(state, movelist[i]); //Call the move function and return the value as test

    if(!test)
    {
      printf("I\n"); //If it is invald, print I
      return;
    }
  }

  printf("%s\n", state); //Print the state
}


/**
 * Initialise a new MoveTree
 */
MoveTree * MoveTree_create(const char * state, const char * moves)
{
  MoveTree * tree = malloc(sizeof(MoveTree)); //Allocate space for a new tree

  //Check for allocation errors
  if(tree == NULL)
  {
    printf("Memory allocated incorrectly (MoveTree_create)\n");
    return NULL;
  }

  tree -> state = strdup(state); //Dump the string using strdup, given by the 264 course notes

  tree -> moves = strdup(moves); //Dump the string using strdup, given by the 264 course notes

  tree -> left = NULL; //Set the left value to NULL

  tree -> right = NULL; //Set the right value to NULL

  return tree; //Return the tree
}

/**
 * Destroy a tree -- must be safe to call MoveTree_destroy(NULL)
 */
void MoveTree_destroy(MoveTree * node)
{
  if(node == NULL)
  {
    return;
  }

  //Get to the end of the binary tree
  MoveTree_destroy(node -> left);
  MoveTree_destroy(node -> right);

  //Free everything in the node
  free(node -> state);
  free(node -> moves);
  free(node);
}

/**
 * Insert a new node into a tree, keeping in mind that:
 * (1) We do not allow duplicate states.
 * (2) If we attempt to insert a duplicate state, then we keep the
 *     node with the shortest move sequence.
 */
MoveTree * MoveTree_insert(MoveTree * node, const char * state, const char * moves)
{
  if(node == NULL)
  {
    return MoveTree_create(state, moves); //Create a new tree if the node is NULL
  }

  if(strcmp(node -> state, state) < 0)
  {
    //Move to the right if the state is greater than the present state
    node -> right = MoveTree_insert(node -> right, state, moves);
  }
  else if(strcmp(node -> state, state) > 0)
  {
    //Move to the left if the state is less than the present state
    node -> left = MoveTree_insert(node -> left, state, moves);
  }
  else if(strlen(moves) < strlen(node -> moves))
  {
    //If at the correct place, copy over the new string is the new string is shorter
    //Essentially, if if takes less moves to complete the puzzle replace the higher number of moves with the lower number of moves
    strcpy(node -> moves, moves);
  }

  return node;
}

/**
 * Search the tree (rooted at 'node') for a node whose
 * state is 'state'
 */
MoveTree * MoveTree_find(MoveTree * node, const char * state)
{
  if(node == NULL)
  {
    //If the node is empty, return NULL
    return NULL;
  }

  if(strcmp(node -> state, state) > 0)
  {
    //Move to the left if the string comparision is larger than 0
    return MoveTree_find(node -> left, state);
  }
  else if(strcmp(node -> state, state) < 0)
  {
    //Move to the right if the string comparision is smaller than 0
    return MoveTree_find(node -> right, state);
  }

  //If the comparison was 0, we found our node
  return node;
}

/**
 * Print the moves in a move-tree.
 * This function is supplied to you.
 */
void MoveTree_print(MoveTree * node)
{
  if(node == NULL)
    return;
  printf("%s\n", node -> state);
  MoveTree_print(node -> left);
  MoveTree_print(node -> right);
}

/**
 * Generate all possible states from 'state' after 0 to 'n_moves'.
 * Returns a 'MoveTree' which contains all of the unique states
 * reachable from 'state' after '0..n_moves' (inclusive). If the same
 * state can be reached by different move sequences, the prefer the
 * shorter of the two sequences.
 * 
 * To write this function you need to create a list of unique states.
 * To do this, you must store the states in a tree, so that when you
 * insert a new state, you can _quickly_ check if it already exists.
 *
 * You will need to create a 'helper' function. When I wrote this code
 * I used the function signature:
 * 
 * void generateAllHelper(MoveTree * root, // Root of the tree
 *         int n_moves,        // maximum length of a movelist
 *         const char * state, // the current state of the puzzle
 * 	   char * movelist,    // the current movelist
 *         int ind)            // the next index to write in movelist
 *
 * This recursive helper function works as follows:
 * (1) The base case: ind == n_moves. Do _nothing_ and return
 * (2) The recursive case:
 *    (2.a) Iterate over the possible moves { 'U', 'D', 'L', 'R'}
 *        (2.a.i) Duplicate 'state' and store it in 'dup_state'
 *                You do this because you don't want to corrupt 
 *                'state' for any other move sequences.
 *        (2.a.ii) Try to apply move 'm' to 'dup_state. If it doesn't
 *                 work, then do nothing and free 'dup_state'
 *        (2.a.iii) If the move was applied, then insert 'dup_state'
 *                  and 'movelist' into the tree 'root'. Be careful...
 *                  MoveTree_insert(...) expects 'movelist' to be a 
 *                  valid c-string, so you _must_ make sure that the
 *                  null-byte is correctly set.
 *        (2.a.iv) Recursively call generateAllHelper(...) with the
 *                 duplicated state, mutated movelist, and updated ind
 *        (2.a.v) Free 'dup_state'
 *
 * Once you have your helper function written, then you can:
 * (1) Create a 'movelist' buffer that can hold a string of length 
 *     n_moves. (Don't forget the null byte.)
 * (2) Create a MoveTree, with 'state' and an empty move list.
 * (3) Call your helper function.
 * (4) Return the tree.
 *
 * This is the most complex function to write... make sure you break
 * it down, and TEST EACH PART.
 */

void generateAllHelper(MoveTree * root, int n_moves, const char * state, char * movelist, int ind)
{
  //Declaration as given in the comments above
  char moveset[] = {'U', 'D', 'R', 'L'};

  if(n_moves == ind)
  {
    //As stated, base case
    return;
  }

  int i = 0; //Counter variable

  //Iterate through the maximum number of moves
  for(; i < NUMBEROFMOVES; i++)
  {
    char moves = moveset[i]; //Set the current moves to the moves variable
    char * state2 = strdup(state); //Dump the string state into the state2 variable, as given from the 264 course notes

    //If the move is valid
    if(move(state2, moves))
    {
      movelist[ind] = moves; //set the current ind equal to the move
      movelist[ind + 1] = '\0'; //Set the end of the movelist to the null character
      MoveTree_insert(root, state2, movelist); //Insert the new state into the root node
      generateAllHelper(root, n_moves, state2, movelist, ind + 1); //Call the function again with an increased index
    }
    free(state2); //Free the strdup'd string
  }
}



MoveTree * generateAll(char * state, int n_moves)
{ 
  MoveTree * tr = MoveTree_create(state, ""); //Create an empty tree

  char * moves = malloc(sizeof(char) * (n_moves + 1)); //Allocate space for the number of moves and a null character

  moves[n_moves] = '\0'; //Set the end of the array equal to the null character

  generateAllHelper(tr, n_moves, state, moves, 0); //Call the helper function with an index of 0 initially

  free(moves); //Free the allocated array for the moves

  return tr;
}

/**
 * To solve the puzzle:
 * (1) Generate all the possible states up to MAX_SEARCH_DEPTH
 * (2) Search the possibilities for FINAL_STATE
 * (3) If FINAL_STATE isn't found, return NULL
 * (4) If FINAL_STATE is found, then return a copy of the moves.
 */
char * solve(char * state)
{
  MoveTree * tr = generateAll(state, MAX_SEARCH_DEPTH); //Generate all the different binary trees for the max depty given
  MoveTree * sol = MoveTree_find(tr, FINAL_STATE); //Find the final state for the binary tree that is the most shallow

  //If there is no solution
  if(sol == NULL)
  {
    MoveTree_destroy(tr); //Destro the tree
    return NULL;
  }

  char * moves = strdup(sol -> moves); //Dump the move list to the array moves

  MoveTree_destroy(tr); //Destroy the binary tree of all the different solutions
  return moves;
}
